spending swap

struct Datum {
    askedAsset: Value
    offeredAsset: Value
}

enum Redeemer {
    Close 
    Swap
    Update 
}

// Swap validator script parameters
const ASKED_MPH: ByteArray = #
const ASKED_TN: ByteArray = #
const OFFERED_MPH: ByteArray = #
const OFFERED_TN: ByteArray = #
const BEACON_MPH: ByteArray = #
const beaconMph: MintingPolicyHash = MintingPolicyHash::new(BEACON_MPH)
const SELLER_PKH: ByteArray = #
const sellerPkh: PubKeyHash = PubKeyHash::new(SELLER_PKH)
const ESCROW_ENABLED: Bool = false
const ESCROW_ADDR: ByteArray = #
const USER_TOKEN_MPH: ByteArray = #


const MIN_ADA: Int = 2_000_000
const minAdaVal: Value = Value::lovelace(MIN_ADA)

func main(datumIn: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {

    // Get hash of this validator
    vHash : ValidatorHash = ctx.get_current_validator_hash();
    beaconTN: ByteArray = vHash.serialize().slice(2,60); // remove header info
    
    // Calculate the beacon token
    beaconAssetclass: AssetClass = AssetClass::new(
        beaconMph, 
        beaconTN
    );
    beaconVal : Value = Value::new(beaconAssetclass, 1);
    
    tx : Tx = ctx.tx;
    txOutputs : []TxOutput = tx.outputs_locked_by(vHash);

    redeemer.switch {
        Close => { true },
        Swap => { true },
        Update => {
            if (txOutputs.length == 1) {
                txOutputs.head.datum.switch {
                    datumOut: Inline => { 
                        datumOutInline: Datum = Datum::from_data(datumOut.data);
                        print("beaconVal: " + beaconVal.show());
                        print("datumIn askedAsset: "+ datumIn.askedAsset.show());
                        print("datumOut askedAsset: "+ datumOutInline.askedAsset.show());
                        print("datumIn offeredAsset: "+ datumIn.offeredAsset.show());
                        print("datumOut offeredAsset: "+ datumOutInline.offeredAsset.show());
                        print("tx.value_locked_by(vHash): "+ tx.value_locked_by(vHash).show());
                        swapVal: Value = minAdaVal + datumOutInline.offeredAsset + beaconVal;
                        print("swapVal: "+ swapVal.show());
                        tx.is_signed_by(sellerPkh).trace("tx signed: ") &&
                        (tx.value_locked_by(vHash) == (swapVal)).trace("output value: ") 
                        //true
                    },
                    else => false.trace("no inline datum found: ") // No inline datum found
                }
            } else {
                false.trace("no datum found in outputs: ") // No datum found in outputs
            }
        }
    }
}