spending swap

struct Datum {
    askedAsset: Value
    offeredAsset: Value
}

enum Redeemer {
    Close 
    Swap {
        buyerPkh: PubKeyHash
    }
    Update 
}

// Swap validator script parameters
const ASKED_MPH: ByteArray = #
const ASKED_TN: ByteArray = #
const OFFERED_MPH: ByteArray = #
const OFFERED_TN: ByteArray = #
const BEACON_MPH: ByteArray = #
const beaconMph: MintingPolicyHash = MintingPolicyHash::new(BEACON_MPH)
const SELLER_PKH: ByteArray = #
const sellerPkh: PubKeyHash = PubKeyHash::new(SELLER_PKH)
const ESCROW_ENABLED: Bool = false
const ESCROW_ADDR: ByteArray = #
const USER_TOKEN_MPH: ByteArray = #
const userTokenMph: MintingPolicyHash = MintingPolicyHash::new(USER_TOKEN_MPH)

const MIN_ADA: Int = 5_000_000
const minAdaVal: Value = Value::lovelace(MIN_ADA)

func main(datumIn: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {

    // Get hash of this validator
    vHash : ValidatorHash = ctx.get_current_validator_hash();
    beaconTN: ByteArray = vHash.serialize().slice(2,60); // remove header info
    
    // Calculate the beacon token
    beaconAssetclass: AssetClass = AssetClass::new(
        beaconMph, 
        beaconTN
    );
    beaconVal : Value = Value::new(beaconAssetclass, 1);

    // Calculate the offered token
    offeredMph: MintingPolicyHash = MintingPolicyHash::new(OFFERED_MPH);
    offeredAssetclass: AssetClass = AssetClass::new(
        offeredMph, 
        OFFERED_TN
    );
    
    tx : Tx = ctx.tx;
    txOutputsContract : []TxOutput = tx.outputs_locked_by(vHash);
    
    redeemer.switch {
        Close => { true },
        red: Swap => { 
            txOutputsBuyer : []TxOutput = tx.outputs_sent_to(red.buyerPkh);
            if (txOutputsContract.length == 1 && txOutputsBuyer.length >= 1) {
                // Pull out the seller token value
                sellerToken: Map[ByteArray]Int = txOutputsContract.head.value.get_policy(userTokenMph);   
                sellerTokenMap = Map[MintingPolicyHash]Map[ByteArray]Int{userTokenMph: sellerToken};
                sellerTokenVal = Value::from_map(sellerTokenMap);

                // Pull out the buyer token value
                buyerToken: Map[ByteArray]Int = txOutputsBuyer.head.value.get_policy(userTokenMph);   
                buyerTokenMap = Map[MintingPolicyHash]Map[ByteArray]Int{userTokenMph: buyerToken};
                buyerTokenVal = Value::from_map(buyerTokenMap);
             
                txOutputsContract.head.datum.switch {
                    datumOut: Inline => { 
                        datumOutData: Datum = Datum::from_data(datumOut.data);
                        offeredAssetDiffVal: Value = datumIn.offeredAsset - datumOutData.offeredAsset;
                        offeredAssetDiffQty: Int = offeredAssetDiffVal.get(offeredAssetclass);
                        swapVal: Value = minAdaVal + datumOutData.offeredAsset + beaconVal + sellerTokenVal;
                   
                        (datumIn.askedAsset == datumOutData.askedAsset).trace("SV1: ") &&
                        (tx.value_locked_by(vHash) == (swapVal)).trace("SV2: ") &&
                        // Check if askedAsset is in lovelace
                        (if (datumIn.askedAsset.get_lovelace() == 0) {
                            (if (ESCROW_ENABLED) {
                                true
                            } else {
                                buyerVal: Value = minAdaVal + offeredAssetDiffVal + buyerTokenVal;
                                sellerVal: Value =  minAdaVal + datumIn.askedAsset * offeredAssetDiffQty;
                                print("buyerVal: " + buyerVal.show());
                                print("sellerVal: " + sellerVal.show());
                                (buyerVal == txOutputsBuyer.head.value).trace("SV3: ") &&
                                (sellerVal == tx.value_sent_to(sellerPkh)).trace("SV4: ")
                            }) 
                        } else {
                            (if (ESCROW_ENABLED) {
                                true
                            } else {
                                buyerVal: Value = minAdaVal + offeredAssetDiffVal + buyerTokenVal;
                                sellerVal: Value =  datumIn.askedAsset * offeredAssetDiffQty;
                                print("buyerVal: " + buyerVal.show());
                                print("sellerVal: " + sellerVal.show());
                                (buyerVal == txOutputsBuyer.head.value).trace("SV5: ") &&
                                (sellerVal == tx.value_sent_to(sellerPkh)).trace("SV6: ")
                            })
                        })
                    },
                    else => false.trace("no inline datum found: ") // No inline datum found
                }
            } else {
                false.trace("no datum found in outputs: ") // No datum found in outputs
            }
        },
        Update => {
            if (txOutputsContract.length == 1) {
                userToken: Map[ByteArray]Int = txOutputsContract.head.value.get_policy(userTokenMph);
                userTokenMap = Map[MintingPolicyHash]Map[ByteArray]Int{userTokenMph: userToken};
                userTokenVal = Value::from_map(userTokenMap);
                txOutputsContract.head.datum.switch {
                    datumOut: Inline => { 
                        datumOutInline: Datum = Datum::from_data(datumOut.data);
                        swapVal: Value = minAdaVal + datumOutInline.offeredAsset + beaconVal + userTokenVal;
                        tx.is_signed_by(sellerPkh).trace("tx signed: ") &&
                        (tx.value_locked_by(vHash) == (swapVal)).trace("output value: ") 
                    },
                    else => false.trace("no inline datum found: ") // No inline datum found
                }
            } else {
                false.trace("no datum found in outputs: ") // No datum found in outputs
            }
        }
    }
}