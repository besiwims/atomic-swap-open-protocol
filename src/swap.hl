spending swap

struct Datum {
    askedAsset: Value
    offeredAsset: Value
}

enum Redeemer {
    Close {
        sellerTokenTNBA: ByteArray
    }
    Swap {
        buyerPkh: PubKeyHash
    }
    Update 
}

// Contract parameters 
const VERSION: ByteArray = #
const ASKED_MPH: ByteArray = #
const ASKED_TN: ByteArray = #
const OFFERED_MPH: ByteArray = #
const OFFERED_TN: ByteArray = #
const BEACON_MPH: ByteArray = #
const beaconMph: MintingPolicyHash = MintingPolicyHash::new(BEACON_MPH)
const SELLER_PKH: ByteArray = #
const sellerPkh: PubKeyHash = PubKeyHash::new(SELLER_PKH)
const ESCROW_ENABLED: Bool = false
const ESCROW_HASH: ByteArray = #
const USER_TOKEN_MPH: ByteArray = #
const userTokenMph: MintingPolicyHash = MintingPolicyHash::new(USER_TOKEN_MPH)
const SERVICE_FEE: Int = 0
const OWNER_PKH: ByteArray = #
const ownerPkh: PubKeyHash = PubKeyHash::new(OWNER_PKH)
const MIN_ADA: Int = 2_500_000
const minAdaVal: Value = Value::lovelace(MIN_ADA)
const DEPOSIT_ADA: Int = 0
const depositAdaVal: Value = Value::lovelace(DEPOSIT_ADA)

func main(datumIn: Datum, redeemer: Redeemer, ctx: ScriptContext) -> Bool {

    // Get hash of this validator
    sHash : ValidatorHash = ctx.get_current_validator_hash();
    beaconTN: ByteArray = sHash.serialize().slice(2,60); // remove header info
    
    // Calculate the beacon token
    beaconAssetclass: AssetClass = AssetClass::new(
        beaconMph, 
        beaconTN
    );
    beaconVal : Value = Value::new(beaconAssetclass, 1);

    // Calculate the offered token
    offeredMph: MintingPolicyHash = MintingPolicyHash::new(OFFERED_MPH);
    offeredAssetclass: AssetClass = AssetClass::new(
        offeredMph, 
        OFFERED_TN
    );
    
    tx : Tx = ctx.tx;
    txOutputsContract : []TxOutput = tx.outputs_locked_by(sHash);
    
    redeemer.switch {
        red: Close => {
            // Create beacon token value for burning
            beaconTokenBurnVal: Value = Value::new(beaconAssetclass, (-1));
            // Creaet seller token that will be sent back to the seller
            sellerTokenAssetclass: AssetClass = AssetClass::new(
                userTokenMph, 
                red.sellerTokenTNBA
            );
            sellerTokenVal : Value = Value::new(sellerTokenAssetclass, 1);

            (txOutputsContract.length == 0).trace("SV1.1: ") &&
            tx.is_signed_by(sellerPkh).trace("SV1.2: ") &&
            (tx.minted == beaconTokenBurnVal).trace("SV1.3: ") &&
            (tx.value_sent_to(sellerPkh).contains(sellerTokenVal)).trace("SV1.4: ")
        },
        red: Swap => { 
            txOutputsBuyer : []TxOutput = tx.outputs_sent_to(red.buyerPkh);
            txOutputsOwner : []TxOutput = tx.outputs_sent_to(ownerPkh);
            if (txOutputsContract.length == 1 && txOutputsBuyer.length >= 1) {
                // Pull out the seller token value & tn (pkh)
                sellerToken: Map[ByteArray]Int = txOutputsContract.head.value.get_policy(userTokenMph);   
                sellerTN: String = (sellerToken.head_key).slice(0,56).decode_utf8();
                sellerTokenMap = Map[MintingPolicyHash]Map[ByteArray]Int{userTokenMph: sellerToken};
                sellerTokenVal = Value::from_map(sellerTokenMap);

                // Pull out the buyer token value & tn (pkh)
                buyerToken: Map[ByteArray]Int = txOutputsBuyer.head.value.get_policy(userTokenMph);   
                buyerTN: String = (buyerToken.head_key).slice(0,56).decode_utf8();
                buyerTokenMap = Map[MintingPolicyHash]Map[ByteArray]Int{userTokenMph: buyerToken};
                buyerTokenVal = Value::from_map(buyerTokenMap);
             
                txOutputsContract.head.datum.switch {
                    datumOut: Inline => { 
                        datumOutData: Datum = Datum::from_data(datumOut.data);
                        offeredAssetDiffVal: Value = datumIn.offeredAsset - datumOutData.offeredAsset;
                        offeredAssetDiffQty: Int = offeredAssetDiffVal.get(offeredAssetclass);
                        feeVal: Value = Value::lovelace(SERVICE_FEE);

                        (datumIn.askedAsset == datumOutData.askedAsset).trace("SV2.1: ") &&
                        
                        // Check if askedAsset is in lovelace, if not then need to add minAdaVal
                        (if (datumIn.askedAsset.get_lovelace() == 0) {
                            (if (ESCROW_ENABLED) {
                                swapVal: Value = minAdaVal + datumOutData.offeredAsset + beaconVal + sellerTokenVal;
                                buyerVal: Value = offeredAssetDiffVal;
                                sellerVal: Value =  datumIn.askedAsset * offeredAssetDiffQty;
                                escrowVal: Value = minAdaVal + depositAdaVal + buyerVal + sellerVal;
                                buyerPkh: PubKeyHash = tx.signatories.head;
                                eHash = ValidatorHash::new(ESCROW_HASH);
                                
                                (tx.value_locked_by(sHash) == (swapVal)).trace("SV2.2: ") &&
                                (tx.value_locked_by(eHash) == (escrowVal)).trace("SV2.3: ") &&
                                (feeVal == txOutputsOwner.head.value).trace("SV2.4: ") &&
                                (sellerTN == SELLER_PKH.show()).trace("SV2.5: ") &&
                                (buyerTN == buyerPkh.show()).trace("SV2.6: ") &&
                                (minAdaVal + buyerTokenVal == txOutputsBuyer.head.value).trace("SV2.7: ")
                            } else {
                                swapVal: Value = minAdaVal + datumOutData.offeredAsset + beaconVal + sellerTokenVal;
                                buyerVal: Value = minAdaVal + offeredAssetDiffVal + buyerTokenVal;
                                sellerVal: Value =  minAdaVal + datumIn.askedAsset * offeredAssetDiffQty;
                                buyerPkh: PubKeyHash = tx.signatories.head;
                                
                                (tx.value_locked_by(sHash) == (swapVal)).trace("SV3.1: ") &&
                                (buyerVal == txOutputsBuyer.head.value).trace("SV3.2: ") &&
                                (sellerVal == tx.value_sent_to(sellerPkh)).trace("SV3.3: ") &&
                                (feeVal == txOutputsOwner.head.value).trace("SV3.3: ") &&
                                (sellerTN == SELLER_PKH.show()).trace("SV3.4: ") &&
                                (buyerTN == buyerPkh.show()).trace("SV3.5: ")
                            }) 
                        } else {
                            (if (ESCROW_ENABLED) {
                                swapVal: Value = minAdaVal + datumOutData.offeredAsset + beaconVal + sellerTokenVal;
                                buyerVal: Value = offeredAssetDiffVal;
                                sellerVal: Value =  datumIn.askedAsset * offeredAssetDiffQty;
                                escrowVal: Value = depositAdaVal + buyerVal + sellerVal;
                                buyerPkh: PubKeyHash = tx.signatories.head;
                                eHash = ValidatorHash::new(ESCROW_HASH);

                                (tx.value_locked_by(sHash) == (swapVal)).trace("SV4.1: ") &&
                                (tx.value_locked_by(eHash) == (escrowVal)).trace("S4.2: ") &&
                                (feeVal == txOutputsOwner.head.value).trace("SV4.3: ") &&
                                (sellerTN == SELLER_PKH.show()).trace("SV4.4: ") &&
                                (buyerTN == buyerPkh.show()).trace("SV4.5: ") &&
                                (minAdaVal + buyerTokenVal == txOutputsBuyer.head.value).trace("SV4.6: ")
                            } else {
                                swapVal: Value = minAdaVal + datumOutData.offeredAsset + beaconVal + sellerTokenVal;
                                buyerVal: Value = minAdaVal + offeredAssetDiffVal + buyerTokenVal;
                                sellerVal: Value =  datumIn.askedAsset * offeredAssetDiffQty;
                                buyerPkh: PubKeyHash = tx.signatories.head;

                                (tx.value_locked_by(sHash) == (swapVal)).trace("SV5.1: ") &&
                                (buyerVal == txOutputsBuyer.head.value).trace("SV5.2: ") &&
                                (sellerVal == tx.value_sent_to(sellerPkh)).trace("SV5.3: ") &&
                                (feeVal == txOutputsOwner.head.value).trace("SV5.4: ") &&
                                (sellerTN == SELLER_PKH.show()).trace("SV5.5: ") &&
                                (buyerTN == buyerPkh.show()).trace("SV5.6: ")
                            })
                        })
                    },
                    else => false.trace("SV6.1: ") // No inline datum found
                }
            } else {
                false.trace("SV6.2: ") // No datum found in outputs
            }
        },
        Update => {
            if (txOutputsContract.length == 1) {
                userToken: Map[ByteArray]Int = txOutputsContract.head.value.get_policy(userTokenMph);
                userTokenMap = Map[MintingPolicyHash]Map[ByteArray]Int{userTokenMph: userToken};
                userTokenVal = Value::from_map(userTokenMap);
                txOutputsContract.head.datum.switch {
                    datumOut: Inline => { 
                        datumOutInline: Datum = Datum::from_data(datumOut.data);
                        swapVal: Value = minAdaVal + datumOutInline.offeredAsset + beaconVal + userTokenVal;
                        
                        tx.is_signed_by(sellerPkh).trace("SV7.1: ") &&
                        (tx.value_locked_by(sHash) == (swapVal)).trace("SV7.2: ") 
                    },
                    else => false.trace("SV7.3: ") // No inline datum found
                }
            } else {
                false.trace("SV7.4: ") // No datum found in outputs
            }
        }
    }
}